<!DOCTYPE html>
<html>
	<head>
		<style>
			* {
				padding:0;
				margin:0;
			}
		</style>
	</head>
	<body>
		<canvas id="gl"></canvas>
		<script type="module">
			import * as THREE from "./node_modules/three/build/three.module.js"
			import { VRButton } from './node_modules/three/examples/jsm/webxr/VRButton.js';
			import { XRControllerModelFactory } from './node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js';
			import { XRHandModelFactory } from './node_modules/three/examples/jsm/webxr/XRHandModelFactory.js';

			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			const cameraBase = new THREE.Object3D()
			scene.add(cameraBase)
			cameraBase.add(camera)

			const renderer = new THREE.WebGLRenderer({canvas:document.getElementById("gl")});
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor(new THREE.Color(0, 0, 1))

			const light = new THREE.DirectionalLight(0xffffff, 1.5)
			light.position.set(1, 0.5, -0.8)
			scene.add(light)

			const light2 = new THREE.DirectionalLight(0xffffff, 0.8)
			light2.position.set(-0.9, 0.4, 0.9)
			scene.add(light2)

			const baseHeight = 10

			const floorGeometry = new THREE.PlaneGeometry( 50, 50, 100, 100 );
			const floorMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff } );
			floorMaterial.flatShading = true
			//floorMaterial.vertexColors = true
			const floor = new THREE.Mesh( floorGeometry, floorMaterial );
			floor.rotation.x = - Math.PI / 2;
			floor.position.y = -baseHeight
			floor.receiveShadow = true;
			scene.add( floor );

			const waters = []
			for (let i = 1; i < 8; i++) {
				const waterGeometry = new THREE.PlaneGeometry( 50, 50 );
				const waterMaterial = new THREE.MeshStandardMaterial( { color: 0xccccff, opacity: 0.5 + 0.05 * i } );
				waterMaterial.flatShading = true
				waterMaterial.transparent = true
				const water = new THREE.Mesh( waterGeometry, waterMaterial );
				water.rotation.x = - Math.PI / 2;
				water.position.y = -baseHeight -0.05 * i * i
				water.receiveShadow = true;
				scene.add( water );
				waters.push(water)
			}

			let ball1Radius = 1
			const ballGeometry1 = new THREE.SphereGeometry(1)
			const ballMaterial1 = new THREE.MeshBasicMaterial({color:0xff0000, opacity: 0.5})
			ballMaterial1.transparent =  true
			const ball1 = new THREE.Mesh(ballGeometry1, ballMaterial1)
			ball1.scale.x = ball1Radius / 2
			ball1.scale.y = ball1Radius / 2
			ball1.scale.z = ball1Radius / 2
			scene.add(ball1)

			const ballGeometry2 = new THREE.SphereGeometry(0.1)
			const ballMaterial2 = new THREE.MeshBasicMaterial({color:0x0000ff})
			const ball2 = new THREE.Mesh(ballGeometry2, ballMaterial2)
			scene.add(ball2)


				// controllers

				const controller1 = renderer.xr.getController( 0 );
				controller1.addEventListener( 'selectstart', () => { controller1.userData.selected = true } );
				controller1.addEventListener( 'selectend', () => { controller1.userData.selected = false } );
				controller1.addEventListener( 'squeezestart', () => { controller1.userData.squeezed = true } );
				controller1.addEventListener( 'squeezeend', () => { controller1.userData.squeezed = false } );
				cameraBase.add(controller1)

				const controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'selectstart', () => { controller2.userData.selected = true } );
				controller2.addEventListener( 'selectend', () => { controller2.userData.selected = false } );
				controller2.addEventListener( 'squeezestart', () => { controller2.userData.squeezed = true } );
				controller2.addEventListener( 'squeezeend', () => { controller2.userData.squeezed = false } );
				cameraBase.add(controller2)

				const controllerModelFactory = new XRControllerModelFactory();
				const handModelFactory = new XRHandModelFactory().setPath( "./models/fbx/" );

				// Hand 1: right
				const controllerGrip1 = renderer.xr.getControllerGrip( 0 );
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
				cameraBase.add( controllerGrip1 );

				const hand1 = renderer.xr.getHand( 0 );
				hand1.add( handModelFactory.createHandModel( hand1 ) );

				cameraBase.add( hand1 );

				// Hand 2: left
				const controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				cameraBase.add( controllerGrip2 );

				const hand2 = renderer.xr.getHand( 1 );
				hand2.add( handModelFactory.createHandModel( hand2 ) );
				cameraBase.add( hand2 );

				//

				const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

				const line = new THREE.Line( geometry );
				line.name = 'line';
				line.scale.z = 10;

				controller1.add( line.clone() );
				controller2.add( line.clone() );

				//

			const raycaster = new THREE.Raycaster()

			// XR
			document.body.appendChild( VRButton.createButton( renderer ) );
			renderer.xr.enabled = true;
			renderer.setAnimationLoop( function () {

				// 地形操作
				const direction1 = new THREE.Vector3(0, 0, -1)
				const controller1Mat = new THREE.Matrix4().makeRotationFromEuler(controller1.rotation)
				const cameraBase1Mat = new THREE.Matrix4().makeRotationFromEuler(cameraBase.rotation)
				const rotation1 = cameraBase1Mat.multiply(controller1Mat)
				const position1 = controller1.position.clone().applyEuler(cameraBase.rotation).add(cameraBase.position)
				direction1.applyMatrix4(rotation1)

				raycaster.set(position1, direction1)

				let intersects = raycaster.intersectObject(floor)
				if (0 < intersects.length) {
					// 地形操作
					const intersect = intersects[0]
					ball1.position.copy(intersect.point)

					const maxHeight = 10
					if (controller1.userData.selected) {
						// 盛り上げる
						transformPlane(intersect, ball1Radius, maxHeight, 1)
					} else if (controller1.userData.squeezed) {
						// 凹ませる
						transformPlane(intersect, ball1Radius, maxHeight, -1)
					} 
				} else {
					// 操作範囲変更
					if (controller1.userData.selected) {
						// 大きく
						ball1Radius = Math.min(ball1Radius + 0.01, 10)
						ball1.scale.x = ball1Radius / 2
						ball1.scale.y = ball1Radius / 2
						ball1.scale.z = ball1Radius / 2
					} else if (controller1.userData.squeezed) {
						// 小さく
						ball1Radius = Math.max(ball1Radius - 0.01, 1)
						ball1.scale.x = ball1Radius / 2
						ball1.scale.y = ball1Radius / 2
						ball1.scale.z = ball1Radius / 2
					} 
				}

				// 移動
				const direction2 = new THREE.Vector3(0, 0, -1)
				const controller2Mat = new THREE.Matrix4().makeRotationFromEuler(controller2.rotation)
				const cameraBase2Mat = new THREE.Matrix4().makeRotationFromEuler(cameraBase.rotation)
				const rotation2 = cameraBase2Mat.multiply(controller2Mat)
				const position2 = controller2.position.clone().applyEuler(cameraBase.rotation).add(cameraBase.position)
				direction2.applyMatrix4(rotation2)

				raycaster.set(position2, direction2)

				intersects = raycaster.intersectObject(floor)
				if (0 < intersects.length) {
					// 平面移動
					const intersect = intersects[0]
					ball2.position.copy(intersect.point)

					const direction = new THREE.Vector2(intersect.point.x, intersect.point.z)
					direction.normalize()
					direction.multiplyScalar(0.05)

					// 前後
					if (controller2.userData.selected) {
						// 前進
						cameraBase.position.x += direction.x
						cameraBase.position.z += direction.y
					} else if (controller2.userData.squeezed) {
						// 後退
						cameraBase.position.x -= direction.x
						cameraBase.position.z -= direction.y
					} 

					// 回転
					if (controller2.userData.selected || controller2.userData.squeezed) {
						const cameraDirection3 = camera.getWorldDirection(new THREE.Vector3())
						cameraDirection3.applyMatrix4(cameraBase2Mat)
						const cameraDirection2 = new THREE.Vector2(cameraDirection3.x, cameraDirection3.z)
						let angle = Math.acos(direction.dot(cameraDirection2)/direction.length()/cameraDirection2.length())

						if (controller2.userData.selected) {
							angle *= -1
						}

						// 回転
						if (0 < direction.cross(cameraDirection2)) {
							cameraBase.rotation.y -= 0.005 * angle
						} else {
							cameraBase.rotation.y += 0.005 * angle
						}
					}
				} else {
					// 上下移動
					const speed = 0.05
					if (controller2.userData.selected) {
						// 上昇
						cameraBase.position.y += speed
					} else if (controller2.userData.squeezed) {
						// 下降
						cameraBase.position.y -= speed
					} 
				}

				renderer.render( scene, camera );
			} );

			function getNearestFaceVertex(objPosition, intersect) {
				const point = intersect.point
				const face = intersect.face

				let nearestDist = Number.POSITIVE_INFINITY
				let nearestPoint
				let nearestId
				for (let pid of [face.a, face.b, face.c]) {
					const vertex = getFaceVertex(objPosition, pid)
					const dist = point.distanceTo(vertex)
					if (dist < nearestDist) {
						nearestPoint = point
						nearestId = pid
					}
				}
				return [nearestId, nearestPoint]
			}

			function getFaceVertex(objPosition, id) {
				return new THREE.Vector3(objPosition.getX(id), objPosition.getY(id), objPosition.getZ(id))
			}
			
			function transformPlane(intersect, radius, maxHeight, direction) {
				radius = Math.floor(radius)
				const objPosition = intersect.object.geometry.getAttribute("position")
				const [base, basePoint] = getNearestFaceVertex(objPosition, intersect)
				for (let dy = -radius; dy <= radius; dy++) {
					for (let dx = -radius; dx <= radius; dx++) {
						const len = Math.sqrt(dx * dx + dy * dy)
						if (len < radius) {
							const coeff = (Math.cos(len / radius * Math.PI) + 1) / 2 * (direction < 0 ? -1 : 1)
							const pid = base + dx * 101 + dy
							const z = objPosition.getZ(pid)
							objPosition.setZ(pid, Math.min(z + 0.01 * coeff, maxHeight))
						}
					}
				}
				objPosition.needsUpdate = true
				intersect.object.geometry.computeVertexNormals()
			}
		</script>
	</body>
</html>